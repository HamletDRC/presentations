
GEP 8 - Static type checking 

The goal of Grumpy is to have a static type checker for Groovy driven by an annotation. This will be optional and not cause any changes to normal Groovy. We see this as part of the Java migration story, in which people may not want the dynamic type system of Groovy everywhere.
* not static compiler
* no new syntax
* Don't want a 3rd language that isn't quite Groovy anymore
* All the docs implies the audience is Java developers coming new to Groovy. Is it safe to say this feature is to stimulate language adoption not improve your productivity. 
* Static type checking: the generated bytecode and runtime behaviour will be exactly the same as if you did not activate this mode.
* This is a major difference from an alternate compiler like Groovy++ which will perform STC then produce a different bytecode and therefore produce different runtime semantics. 
 * check for missing methods or properties and report error
 * check for type safety
 * type inferrence
 * support for "GDK methods", that is to say methods added by Groovy to common classes, aka extension methods
 * support for Groovy idiomatic constructs like with, each, ...







Difficulties: 
  * Generics, especially with closures
  * delegate object

Debated: 
    unification types
    static compilation

  Flow Sensitive Typing (not really approved)
  * Grumpy will be more advanced than Java. It will deal with reassignments. 
  * The GEP contains no flow sensitive typing
    def v = 1; v = v.toString(); println v.toUpperCase()
  
    not allowed: int i = new Object()


GEP 10 - Static compilation
    we do not plan to change the semantics of regular Groovy
    we want static compilation to be triggered explicitly
    we want the semantics of static groovy to be as close as possible as the semantics of dynamic Groovy
    While static type checking will most probably be part of Groovy 2.0, it's still unsure about static compilation

Issues: 
  Method Selection
The current implementation relies on the static type checker, which performs type inference
@groovy.transform.CompileStatic
int fib(int i) {
    i < 2 ? 1 : fib(i - 2) + fib(i - 1)
}


The third solution I presented is the one currently implemented in the experimental compiler: inference based method dispatch. This definitely creates a third language in terms of dispatch semantics, but as the developer explicitly adds an annotation, he should be aware of the differences (which only occur when you have overloaded methods). Inference based dispatch also has the advantage of being "flow typing" compatible, and removes a lot of verbosity. It has my preference, which explains why this is what is implemented right now.

  
